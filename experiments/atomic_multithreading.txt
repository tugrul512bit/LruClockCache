#include <iostream>


#include<vector>
#include<atomic>

template<typename CacheKey,
typename CacheValue>
class CacheGetSetFlushCommand
{
  public:
  CacheGetSetFlushCommand()
  {
    command=0; // no operation
  }
  CacheKey key;
  CacheValue value;
  char command; // 1=get, 2=set, 3=flush
  std::atomic<bool> busy;
}

template<typename CacheCommand>
class CachePipe
{
  public:
  CachePipe(int size)
  {
    busy.store(0);
    head.store(0);
    tail=0;
    cmd=std::vector<CacheCommand>(65536);
  }
  
  void producerPush(CacheCommand cmd)
  {
    char16_t cur=head.fetch_add(1);
    bool bus=cmdQ[cur].busy.load(std::memory_order::acq);
    while(!bus)
    {
      std::this_thread::yield();
      bus=cmdQ[cur].busy.load(std::memory_order::acq);
    }
    cmdQ[head]=cmd;
    bus.store(true,std::memory_order::rel);
  }
  
  CacheCommand consumerPop()
  {
    char16_t cur=tail++;
    bool bus=cmdQ[cur].busy.load(std::memory_order::acq);
    while(bus)
    {
      std::this_thread::yield();
      bus=cmdQ[cur].busy.load(std::memory_order::acq);
    }
    
    CacheCommand cmd=cmdQ[cur];
    cmdQ[cur].busy.store(false,std::memory_order::rel);
    return cmd;
  }
  
  private:
  std::vector<CacheCommand> cmdQ;
  std::atomic<char16_t> head;
  char16_t tail;
  std::atomic<bool> busy;
};

int main() 
{
  
    cout << "Hello, World!";
    return 0;
}
